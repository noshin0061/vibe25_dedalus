from __future__ import annotations

from datetime import datetime, timezone
from typing import Any, Dict, List, Optional
from uuid import uuid4

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field, ValidationError, validator

try:
    from dotenv import load_dotenv
except ImportError:  # pragma: no cover - optional dependency
    load_dotenv = None

from dedalus_labs import AsyncDedalus, DedalusError, DedalusRunner

if load_dotenv is not None:
    load_dotenv()


def _isoformat(dt: datetime) -> str:
    """Return UTC ISO-8601 string without offset suffix."""
    return dt.astimezone(timezone.utc).isoformat().replace("+00:00", "Z")


class MCPServerResolved(BaseModel):
    """Resolved MCP server descriptor."""

    id: str = Field(..., description="Identifier of the MCP server.")
    version: Optional[str] = Field(None, description="Optional version string.")


class UsageMetrics(BaseModel):
    """Token accounting for the run."""

    promptTokens: Optional[int] = Field(None, description="Number of prompt tokens consumed.")
    completionTokens: Optional[int] = Field(None, description="Number of completion tokens consumed.")
    totalTokens: Optional[int] = Field(None, description="Total tokens consumed.")


class Timings(BaseModel):
    """Timing metadata for the run."""

    startedAt: str = Field(..., description="UTC ISO-8601 timestamp when execution started.")
    finishedAt: str = Field(..., description="UTC ISO-8601 timestamp when execution finished.")


class ExecuteRequest(BaseModel):
    """Request schema for executing a Dedalus run."""

    input: str = Field(..., description="User input passed to the runner.")
    model: str = Field(..., description="Model identifier to execute.")
    mcpServers: List[str] = Field(..., description="List of MCP server identifiers.")

    @validator("input", "model")
    def _non_empty(cls, value: str) -> str:
        if not value or not value.strip():
            raise ValueError("Field must be a non-empty string.")
        return value

    @validator("mcpServers")
    def _validate_servers(cls, value: List[str]) -> List[str]:
        if not value:
            raise ValueError("mcpServers must include at least one server.")
        sanitized = []
        for server in value:
            if not server or not server.strip():
                raise ValueError("Each MCP server entry must be a non-empty string.")
            sanitized.append(server.strip())
        return sanitized


class ExecuteResponse(BaseModel):
    """Response schema returned after executing a Dedalus run."""

    runId: str = Field(..., description="Short identifier for the run.")
    model: str = Field(..., description="Resolved model identifier that was executed.")
    mcpServersResolved: List[MCPServerResolved] = Field(
        ..., description="Resolved metadata for each MCP server."
    )
    finalOutput: str = Field(..., description="Final output generated by Dedalus.")
    usage: Optional[UsageMetrics] = Field(None, description="Optional token usage information.")
    timings: Optional[Timings] = Field(None, description="Execution timing metadata.")


app = FastAPI(title="Dedalus Execution API", version="1.0.0")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

dedalus_client: Optional[AsyncDedalus] = None
dedalus_runner: Optional[DedalusRunner] = None


@app.on_event("startup")
async def _startup() -> None:
    """Initialize the shared Dedalus client and runner."""
    global dedalus_client, dedalus_runner
    if dedalus_client is None or dedalus_runner is None:
        dedalus_client = AsyncDedalus()
        dedalus_runner = DedalusRunner(dedalus_client)


def _extract_usage(data: Any) -> Optional[UsageMetrics]:
    """Extract usage metrics from a Dedalus response, if present."""
    usage_source = getattr(data, "usage", None) or getattr(data, "token_usage", None)
    if isinstance(usage_source, dict):
        return UsageMetrics(
            promptTokens=usage_source.get("prompt_tokens") or usage_source.get("promptTokens"),
            completionTokens=usage_source.get("completion_tokens") or usage_source.get("completionTokens"),
            totalTokens=usage_source.get("total_tokens") or usage_source.get("totalTokens"),
        )
    return None


def _resolve_mcp_servers(response: Any, requested: List[str]) -> List[MCPServerResolved]:
    """Best-effort mapping of MCP servers from the response data."""
    resolved: List[MCPServerResolved] = []
    candidate = getattr(response, "mcp_servers", None) or getattr(response, "mcpServers", None)

    if isinstance(candidate, list) and candidate:
        for item in candidate:
            if isinstance(item, dict):
                server_id = item.get("id") or item.get("name")
                if server_id:
                    resolved.append(MCPServerResolved(id=str(server_id), version=item.get("version")))
            elif isinstance(item, str):
                resolved.append(MCPServerResolved(id=item))

    if not resolved:
        resolved = [MCPServerResolved(id=server) for server in requested]

    return resolved


@app.get("/execute")
async def execute_healthcheck() -> Dict[str, str]:
    """Simple GET healthcheck for load balancers expecting 200 on /execute."""
    return {"status": "ok"}


@app.post("/execute", response_model=ExecuteResponse)
async def execute(body: ExecuteRequest) -> ExecuteResponse:
    """Run a Dedalus unified execution for the provided input/model/server tuple."""
    if dedalus_runner is None:
        raise HTTPException(status_code=503, detail="Runner is not initialized.")

    started = datetime.now(timezone.utc)
    run_identifier = uuid4().hex[:8]

    try:
        result = await dedalus_runner.run(
            input=body.input,
            model=body.model,
            mcp_servers=body.mcpServers,
        )
    except ValidationError as exc:
        raise HTTPException(status_code=400, detail=str(exc)) from exc
    except ValueError as exc:
        raise HTTPException(status_code=400, detail=str(exc)) from exc
    except DedalusError as exc:
        raise HTTPException(status_code=502, detail=str(exc)) from exc
    except Exception as exc:
        raise HTTPException(status_code=502, detail=str(exc)) from exc

    finished = datetime.now(timezone.utc)
    final_output = getattr(result, "final_output", "") or ""

    response_payload = ExecuteResponse(
        runId=run_identifier,
        model=body.model,
        mcpServersResolved=_resolve_mcp_servers(result, body.mcpServers),
        finalOutput=final_output,
        usage=_extract_usage(result),
        timings=Timings(startedAt=_isoformat(started), finishedAt=_isoformat(finished)),
    )
    return response_payload


if __name__ == "__main__":
    import uvicorn

    # Quick self-test:
    # curl -s -X POST http://localhost:8000/execute \
    #   -H "Content-Type: application/json" \
    #   -d '{"input":"Hello","model":"openai/gpt-5-mini","mcpServers":["windsor/exa-search-mcp"]}'
    uvicorn.run("app:app", host="0.0.0.0", port=8000, reload=False)
